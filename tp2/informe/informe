Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
 _____      _                 _                _                 
|_   _|    | |               | |              (_)              _ 
  | | _ __ | |_ _ __ ___   __| |_   _  ___ ___ _  ___  _ __   (_)
  | || '_ \| __| '__/ _ \ / _` | | | |/ __/ __| |/ _ \| '_ \     
 _| || | | | |_| | | (_) | (_| | |_| | (_| (__| | (_) | | | |  _ 
 \___/_| |_|\__|_|  \___/ \__,_|\__,_|\___\___|_|\___/|_| |_| (_)



       ....           urante la realización de este trabajo práctico hemos tenido que enfrentar
   .xH888888Hx.       la problemática de diseñar algoritmos que aprovechen el modelo SIMD 
 .H8888888888888:     provisto por la arquitectura Intel. Procesamos imágenes aplicando
 888*"""?""*88888X    distintos filtros implementados en el lenguaje ANSI-C y en el lenguaje 
'f     d8x.   ^%88k   Ensamblador (utilizando instrucciones SSE) y comparamos el rendimiento
'>    <88888X   '?8   obtenido. 
 `:..:`888888>    8> 
        `"*88     X     Los filtros a implementar eran rotar, monocromatizar, sepia, blit, 
   .xHHhx.."      !   scale2x, smalltiles, edge-detection y blur, que serán descriptos 
  X88888888hx. ..!    pertinentemente más adelante. 
 !   "*888888888"    
        ^"***"`         Para facilitar las pruebas y mediciones sobre los algoritmos, la 
cátedra nos ha provisto una cómoda interfaz de trabajo utilizando la librería de visión 
computacional "OpenCv" la cual nos entrega las imágenes en memoria, listas para ser procesadas,
 en un formato homogéneo (un byte por canal RGB).


______                               _ _           
|  _  \                             | | |        _ 
| | | |___  ___  __ _ _ __ _ __ ___ | | | ___   (_)
| | | / _ \/ __|/ _` | '__| '__/ _ \| | |/ _ \     
| |/ /  __/\__ \ (_| | |  | | | (_) | | | (_) |  _ 
|___/ \___||___/\__,_|_|  |_|  \___/|_|_|\___/  (_)

                                                        88""Yb  dP"Yb  888888    db    88""Yb 
                                                        88__dP dP   Yb   88     dPYb   88__dP 
                                                        88"Yb  Yb   dP   88    dP__Yb  88"Yb  
                                                        88  Yb  YbodP    88   dP""""Yb 88  Yb 

    El filtro rotar (o feel like Hulk) consiste en rotar los canales RGB de una imagen de la 
siguiente manera:
                        +----------+----------+----------+
                        |  88""Yb  |  dP""b8  |  88""Yb  |
                        |  88__dP  | dP   `"  |  88__dP  |
                        |  88"Yb   | Yb  "88  |  88""Yb  |
                        |  88  Yb  |  YboodP  |  88oodP  |
                        +----------+----------+----------+
                             +---+      |          |
                                 v      |          |
                             +----------+   +------+
                             |   v          v
                             |   +-------------------+
                             |              v        |
                             v              v        v
                        +----------+----------+----------+
                        |  dP""b8  |  88""Yb  |  88""Yb  |
                        | dP   `"  |  88__dP  |  88__dP  |
                        | Yb  "88  |  88""Yb  |  88"Yb   |
                        |  YboodP  |  88oodP  |  88  Yb  |
                        +----------+----------+----------+
-----------------------------------------------------------------------------------------------
                                         Hoja 0x1
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                  .-.
Implementación en |   :
                  `-' 

    La implementación de este filtro en el lenguaje ANSI C utilizando un modelo SISD resulta
trivial, iteramos la imagen en memoria recorriendo fila por fila, columna por columna, 
cambiando pixel por pixel el orden de sus componentes RGB.

                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para esta función, iteramos fila por fila, para cada una de ellas, procesamos de a 16 bytes
(4 píxels), cargándolos en registros XMM de forma alineada con la instrucción movdqa. Esto lo
hacemos solo para las direcciones alineadas a 16 bytes, claramente no todas las imágenes tienen
una cantidad de bytes por fila múltiplo de 16, así que para procesar el resto de los bytes
(a lo sumo 15), volvemos para "atras" hasta que nos queden 16 bytes por procesar, luego 
cargamos eso en registros XMM de forma desalineada con la instrucción movdqu.

    El procesamiento de 4 píxeles lo hacemos utilizando la instrucción pshufb, que se encarga
de reordenar los bytes de un registro xmm según una máscara dada.


                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|R3|G3|B3|A2|R2|G2|B2|A1|R1|G1|B1|A0|R0|G0|B0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                         pshufb_mask
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|G3|B3|R3|A2|G2|B2|R2|A1|G1|B1|R1|A0|G0|B0|R0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+



    Cada píxel es un grupo de 4 bytes, cuyas componentes son R, G, B y un byte más utilizado
para alineación. La parte inferior de cada cuadro muestra el índice del byte dentro del
registro xmm, mientras que la parte superior especifica qué componente es y de qué píxel forma
parte; así, se ve cómo el primer píxel intercambia los componentes RGB por GBR como se pide.


    Una vez aplicada la máscara, se mueve de forma alineada a la memoria destinada para la 
imagen resultante, de nuevo, los píxeles restantes se mueven de forma desalineada.








-----------------------------------------------------------------------------------------------
                                         Hoja 0x2
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                         .dP"Y8 8b    d8    db    88     88     888888 88 88     888888 .dP"Y8 
                         `Ybo." 88b  d88   dPYb   88     88       88   88 88     88__   `Ybo." 
                         o.`Y8b 88YbdP88  dP__Yb  88  .o 88  .o   88   88 88  .o 88""   o.`Y8b 
                         8bodP' 88 YY 88 dP""""Yb 88ood8 88ood8   88   88 88ood8 888888 8bodP' 

    Aplicar este filtro no es más que replicar la imagen original 4 veces sobre el destino de 
forma escalada. Básicamente sirve para ahorrarse unos mangos al necesitar fotos 4x4.

    +--------------------------------------+     +--------------------------------------+
    |                                      |     |                  |                   |
    |     ############################     |     |  ##############  |  ##############   |
    |     ############################     |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |                  |                   |
    |                #######               |     +------------------+-------------------+
    |                #######               |     |                  |                   |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |     ############################     |     |        ##        |        ##         |
    |     ############################     |     |  ##############  |  ##############   |
    |                                      |     |                  |                   |
    +--------------------------------------+     +------------------+-------------------+


                  .-.
Implementación en |   :
                  `-' 

    Si la imagen tiene un alto o ancho impar, se descarta el último píxel del lado impar para
poder procesarlo como una imagen con longitudes pares. Se procesa fila por medio, columna por
medio copiando sólo los píxeles en posiciones pares a las 4 posiciones diferentes en la imágen
destino. Se copia componente a componente, primero en el cuadrante superior izquierdo, luego
en el superior derecho, después inferior derecho, y finalmente inferior izquierdo. 












-----------------------------------------------------------------------------------------------
                                         Hoja 0x3
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Dado que sólo tenemos que copiar la mitad de los píxeles (de cada 4 píxeles copiamos el 
primero y el tercero), cargamos 16 bytes en un registro (xmm1), y aplicamos una máscara 
utilizando la instrucción pshufd, la cual reordena los dwords dentro un registro xmm según 
una máscara dada. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                 pshufd_mask (máscara 0x00001000)
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 0  |  Pixel 0  |  Pixel 2  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


    Copiamos la parte baja de este registro xmm resultante a las cuatro posiciones
correspondientes en el destino, en sentido horario, comenzando a partir del segundo cuadrante.
 Esta copia la hacemos usando la instrucción movq.

    Como es observable, si la imágen no tiene tamaño múltiplo de 16, los últimos cuatro píxeles
podrían quedar sin procesar, es por eso que cuando llegamos al final, utilizamos el mismo 
método del filtro anterior para procesarlos, volvemos para atrás lo suficiente para poder 
cargar 16 bytes de forma no alineada en un registro xmm.




                                                                       88""Yb 88     88 888888 
                                                                       88__dP 88     88   88   
                                                                       88""Yb 88  .o 88   88   
                                                                       88oodP 88ood8 88   88  


    El arte del blitting es el proceso de combinar dos mapas de bits en uno solo. Para este
trabajo nos vemos ante la problemática de pegar una imagen sobre otra, asumiendo que el píxel
color magenta representa la transparencia, y, por ende, que de ese pixel queda la imagen de 
fondo. ¿Quién no ha querido sacarse una foto con nuestro compañero, el General Juan Domingo?
Gracias a los avances tecnológicos que nos brinda la manipulación digital de imágenes, con 
BLIT esto es posible. 






-----------------------------------------------------------------------------------------------
                                         Hoja 0x4
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
    +--------------------------------------+                       +-------------------+
    |                      __    __        |        +--+           |      |^ ^|        |
    |                     /  \__/  \__     |        |  |           |      |___|        |
    |  _                 /___         \    |     +--+  +--+        |       \ /         |
    | / \ ____  ____         \__    __/    |     |        |        |       ###   #     |
    |/   /    \/    \           \__/       |     +--+  +--+        |   ###########     |
    |\              /                      |        |  |           |  #   #####        |
    | |  _          \                      |        +--+           |      #####        |
    | \_/ \_________/                      |                       |     #     #       |
    |           3.141592                   |                       |    ##     ##      |
    |          6535897932                  |                       |  ####     ####    |
    |         385626433832                 |                       +-------------------+
    |          7950288419                  |
    |           7169399                    |
    |             |  |                     |
    |             |  |                     |
    |             |  |                  <*>|
    |_____________|  |___________________|_|
    |                                      |
    |                                      |
    |                                      |
    +--------------------------------------+

                           +--------------------------+
                           |                          |
                           |                          |
                           +--------------------------+


                           +--------------------------+
                           |                          |
                           |                          |
                           +--------------------------+


                            +--------------------------------------+
                            |                      __    __        |
                            |                     /  \__/  \__     |
                            |  _                 /___         \    |
                            | / \ ____  ____         \__    __/    |
                            |/   /    \/    \           \__/       |
                            |\              /                      |
                            | |  _          \                      |
                            | \_/ \_________/                      |
                            |           3.141592                   |
                            |          6535897932                  |
                            |         385626433832    |^ ^|        |
                            |          7950288419     |___|        |
                            |           7169399        \ /         |
                            |             |  |         ###   #     |
                            |             |  |     ###########     |
                            |             |  |    #   #####     <*>|
                            |_____________|  |________#####______|_|
                            |                        #     #       |
                            |                       ##     ##      |
                            |                     ####     ####    |
                            +--------------------------------------+


-----------------------------------------------------------------------------------------------
                                         Hoja 0x5
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------


                  .-.
Implementación en |   :
                  `-'

    Ya que sabemos que el blit lo debemos posicionar abajo a la derecha de nuestra imagen
destino, utilizando la función MEMCPY extraída de la librería estándard de ANSI C para copiar
la imagen tal cual en el destino. Esto lo hacemos fila por fila, ya que no podemos pisar la
memoria que hay entre el final de una fila y la fila siguiente (width <= row_size), y tampoco
podemos asumir que src_row_size sea igual a dst_row_size.

    Una vez copiada toda la imagen, procedemos a copiar el blit, recorriendo fila por fila del
blit, columna por columna, copiando los píxeles que no son magenta en la imagen destino.

    Es probable, dependiendo del compilador con la que se haya compilado la LibC de la pc donde
corra el programa, que MEMCPY use instrucciones SSE para realizar la copia. Esto se tendrá en 
cuenta en el análisis de rendimiento.



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para la implementación en ASSEMBLER, aprovechamos lo mismo que en la implementación de C,
copiando primero todas las filas que no entren en el blit " a lo bruto", con la instrucción
movdqa para hacerlo de forma alineada y luego retrocediendo y usando la instrucción movdq para
los, a lo sumo, 15 bytes restantes.

    Una vez llegada a una fila en la que se debería insertar el blit, se van copiando las
columnas hasta llegar a la última que sea múltiplo de 16 sin que empiece formando parte del
blit, se copia, se vuelve al inicio del blit, y se aplica el blit de forma no alineada para 
source (en breve veremos en qué consiste aplicar el blit). Luego se vuelve a ir hacia donde 
nos habíamos quedado, y empezamos a aplicar el blit de forma alineada para source, pero 
desalineada para el blit. Esto es así ya que nada nos asegura que podamos realizar ambas copias
de forma alineada. Finalmente, llegamos a los últimos píxeles que no entran en un registro xmm
sin pisar la memoria fuera de la imagen, por esto, volvemos para atrás la cantidad necesaria
de bytes y volvemos a procesarlos de forma alineada, como hicimos en todos los ejercicios hasta
ahora.

    Aplicar el blit, hace referencia al proceso de mezclar los dos mapas de bit, el de origen
(source), y el del blit, sobre la imagen destino (dest). Esto lo hacemos usando comparaciones
y operaciones lógicas empaquetadas. Se tienen 4 píxeles contiguos cargados en un registro XMM, 
luego se utiliza la operación pcmpeqd que compara, de forma empaquetada, los double-words que
se encuentran en un registro contra los double-words de otro registro, en el cual tenemos 4
double-words con el píxel color magenta. Esto nos genera una máscara con unos en los
double-words que corresponden a píxeles magenta, y 0 donde no hay magenta. Al momento de 
combinarlas, si en el blit tenemos un pixel magenta, queremos que en dest prevalezca el pixel 
de source, si en el blit el píxel no es magenta, en dest debería prevalecer el píxel del blit.
Es por eso, que luego de hacer pcmpeqd, hacemos un pand entre los píxeles de source y los 
resultantes del pcmpeqd, de esta forma, nos quedarían sólo los píxeles de source que 
corresponden a píxeles magenta del blit; luego hacemos pandn entre el resultado de pcmpeqd y
el blit, quedandonos así con los píxeles del blit que no son magenta. Finalmente, combinamos 
ambos registros mediante la instrucción por, es claro ver que o nos queda un pixel de source
o nos queda un pixel de blit, y que no se nos mezclan. En esto consiste "aplicar el blit". 



-----------------------------------------------------------------------------------------------
                                         Hoja 0x6
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

Source:
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

Blit:
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |  MAGENTA  |Pixel 2blit|Pixel 1blit|  MAGENTA  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|             |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+             |
                                                            pcmpeqd----+
Mascara Magenta                                                |       |
 +--+--+--+--+--+--+--+--+--+--+--+--+que en castellano --+--+--+--+             |       |
 |  MAGENTA  |  MAGENTA  |  MAGENTA  |  MAGENTA  |             |       |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+       |
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|                     |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                     |
                                                                       |
                                                                       |
                                             +-------------------------+
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |0xFFFFFFFF |0x00000000 |0x00000000 |0xFFFFFFFF |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  
                                             |
                                             |             
                         +-------------------+----------------------+
                         |                                          |
                      pand Source                              pandn Blit
                         |                                          |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
 |  Pixel 3  |0x00000000 |0x00000000 |  Pixel 0  |                  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|                  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
                         |                                          |
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                  |0x00000000 |Pixel 2blit|Pixel 1blit|0x00000000 |
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                  |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                                          |
                         |                                          |
                         |                    por                   |
                         +---------------------+--------------------+
                                               |
                                               |
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                       |  Pixel 3  |Pixel 2blit|Pixel 1blit|  Pixel 0  |
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                       |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-----------------------------------------------------------------------------------------------
                                         Hoja 0x7
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                  8b    d8  dP"Yb  88b 88  dP"Yb   dP""b8 88  88 88""Yb  dP"Yb  8b    d8 888888
                  88b  d88 dP   Yb 88Yb88 dP   Yb dP   `" 88  88 88__dP dP   Yb 88b  d88 88__  
                  88YbdP88 Yb   dP 88 Y88 Yb   dP Yb      888888 88"Yb  Yb   dP 88YbdP88 88""  
                  88 YY 88  YbodP  88  Y8  YbodP   YboodP 88  88 88  Yb  YbodP  88 YY 88 888888
                  
	El filtro monochrome permite lograr el un curioso efecto vintage, dando la apariencia de 
tratarse de fotografías antiguas. Para lograr dicho efecto basta con multiplicar cada canal por
una constante predefinida para el mismo, sumar los resultados y replicar dicho valor en los
tres canales. Digamos que es el retro de lo digital. Junto con sepia. Nada de cámara blanco y
negro para seguir la old-fashion. No, no, dame la PC que me hago el antiguo, dicen acá.
+----------+               +----------+              +----------+              +----------+
|  88""Yb  |               |  88""Yb  |              |  dP""b8  |              |  88""Yb  |
|  88__dP  |88888       __ |  88__dP  |  ·     __    | dP   `"  |  ·     _     |  88__dP  |
|  88      |       /\ /\ / |  88"Yb   | ---  /\  /|  | Yb  "88  | --- /\  ) |  |  88""Yb  |
|  88      |88888  \/.\// x|  88  Yb  |  ·   \/./ |x |  YboodP  |  ·  \/./_ |x |  88oodP  |
+----------+               +----------+              +----------+              +----------+
 
                        +----------+----------+----------+
                        |  88""Yb  |  88""Yb  |  88""Yb  |
                        |  88__dP  |  88__dP  |  88__dP  |
                        |  88      |  88      |  88      |
                        |  88      |  88      |  88      |
                        +----------+----------+----------+
                        
                        
                  .-.
Implementación en |   :
                  `-'
                  
	La implementación en C es bastante sencilla, recorriendo la imagen pixel a pixel y
aplicando la fórmula obtenemos el valor deseado. Luego lo replicamos en los tres canales del 
destino y obtenemos el resultado buscado.

                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Como tenemos que hacer operaciones aritméticas no enteras necesitamos tener cada número en
formato float para lo cual primero lo desempaquetamos de 8 a 32 bits, quedando los 4 pixels en
4 registros distintos. Y luego convertimos de enteros de 32bits a escalares de presición
simple, que también ocupan 32 bits. En ese momento procedemos a multiplicar por las constantes.
	Luego reempaquetamos con sumas horizontales y reconvertimos a enteros, teniendo así en los
 bytes 0, 4, 8 y 12 los valores requeridos para los pixels 3 2 1 y 0 respectivamente. Solo 
 resta replicar dichos valores en los canales que corresponden y esto lo hacemos a partir de la
instrucción pshufb.

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                            punpck(l/h)bw + punpck(l/h)wd + cvtdq2ps
                                             |
                                             |
                                             |
                                             |
-----------------------------------------------------------------------------------------------
                                         Hoja 0x8
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------		
                                             |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  A Pix0   |  B Pix0   |  G Pix0   |  R Pix0   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    x4  (Pix1, Pix2, Pix3, Pix4)
|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |
                        |
                        |
                        |
                        |
                        |
                        |                                    
                        |                                     CONSTANTES
                        |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |                  |     0     |   0.21    |   0.71    |   0.07    |
                      mulps----------------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |                  |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                        |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |
                        |
             haddps + haddps + haddps + cvtps2dq
                        |
                        |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |        |12|        |08|        |04|        |00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |
                        |
                        |
                        |
                   pshufb (máscara 0x000F444F888FCCCF)
                        |
                        |
                        |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


                                                                   .dP"Y8 888888 88""Yb 88    db    
                                                                   `Ybo." 88__   88__dP 88   dPYb   
                                                                   o.`Y8b 88""   88"""  88  dP__Yb  
                                                                   8bodP' 888888 88     88 dP""""Yb



	Para obtener una imagen en tono sepia o también conocido como solarizar una fotografía
hemos recurrido al método provisto por la cátedra. Se debían sumar los 3 canales de cada pixel
y almacenar dicho resultado en los canales multiplicándolo por la constante correspondiente 
al canal en cuestión. Estas eran 0.5 para el canal R, 0.3 para el canal G y 0.2 para el canal 
B. De este modo se obtiene el característico tono ocre que antiguamente se utilizaba para
preservar por maś tiempo una fotografía en papel evitando el deterioro. Vale destacar que una
fotografía a la que se le aplica esté filtro podrá ser conservada por un largo período si
así se desea.
-----------------------------------------------------------------------------------------------
                                         Hoja 0x9
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------	
+----------+         +----------+       +----------+       +----------+
|  888888  |         |  88""Yb  |       |  dP""b8  |       |  88""Yb  |
|    88    |88888    |  88__dP  |  ||   | dP   `"  |  ||   |  88__dP  |
|    88    |         |  88"Yb   | ====  | Yb  "88  | ====  |  88""Yb  |
|    88    |88888    |  88  Yb  |  ||   |  YboodP  |  ||   |  88oodP  |
+----------+         +----------+       +----------+       +----------+
 
                        +----------+----------+----------+
                        |  888888  |  888888  |  888888  |
                        |    88    |    88    |    88    |
                        |    88    |    88    |    88    |
                        |    88    |    88    |    88    |
                        +----------+----------+----------+
                             |          |          |
                             |          |          |
                             |          |          |
                             v          v          v
                _  _        ___       ____       ____ 
               ( \/ )      / __)     ( __ \     (___ \
                )  (   _  (___ \   _  (__ (   _  / __/
               (_/\_)  (_)(____/  (_)(____/  (_)(____)
                             |          |          |
                             |          |          |
                             |          |          |
                             v          v          v
                        +----------+----------+----------+
                        |  88""Yb  |  dP""b8  |  88""Yb  |
                        |  88__dP  | dP   `"  |  88__dP  |
                        |  88"Yb   | Yb  "88  |  88""Yb  |
                        |  88  Yb  |  YboodP  |  88oodP  |
                        +----------+----------+----------+
                             
                           
                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                    ' `-' '  ` 
    Como tenemos que hacer operaciones aritméticas no enteras necesitamos tener cada número en
formato float para lo cual primero lo desempaquetamos de byte a word bits, quedando los 4 
pixels en 2 registros distintos. Procedemos a sumar horizontalmente obteniendo
las sumas de dos canales en 16 bits de presición otra vez en un solo registro.
	Luego repetimos el procedimiento pero esta vez de word a doubleword, quedandome las cuatro 
sumas de los 4 canales, una por pixel, en 32 bits de presición. Paso a convertir los 
doublewords a escalares de presición simple, los mismos coinciden en tamaño. 
	Llegado a este punto los separo en 4 registros distintos, y luego utilizo un shuffle para 
replicar las correspondientes sumas temporales 4 veces en cada registro. Ahora solo resta 
multiplicar por las constantes que corresponden a cada canal, convertir nuevamente a enteros de
32 bits para reempaquetarlos de double a word y de word a byte progresivamente y guardarlos
en memoria. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                            punpck(l/h)bw + phaddw + punpck(l/h)wd + phaddd + cvtdq2ps
                                             |
                                             |
                                             |
                                             |
                                             |
                                             |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| TMP Pix3  | TMP Pix2  | TMP Pix1  |  TMP Pix0 |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    
|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |
                        |
                        |
                        |
                       shufps x4, llevandome cada TMP a un registro distinto
                        |
                        |
                        |
                        |
                       pshufd en cada uno de esos registros, replicando el TMP 4 veces
                        |
                        |
                        |
                        |
                        |                                     CONSTANTES
                        |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |                  |     0     |    0.5    |    0.3    |    0.2    |
                      mulps----------------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |                  |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                        |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                        |
                        |
                        |
                    packusdw + packusdw + packuswb
                        |
                        |
                        |
                        |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                                         

                                                           888888   8888b.     dP""b8   888888 
                                                           88__      8I  Yb   dP   `"   88__   
                                                           88""      8I  dY   Yb  "88   88""   
                                                           888888   8888Y"     YboodP   888888 

    Edge-Detection, que en castellano significa Detección de Bordes, es como se le llama al 
filtro que, tras aplicarlo a una imagen, nos deja sólo con los "bordes" de las figuras dentro
de ella. Se conoce como un borde a un punto en donde hubo un cambio bruzco de intensidad
de luz. Existen varias formas de detectar dichos bordes, una de ellas es calculando la 
derivada de la intensidad del brillo píxel a píxel. Para esto, se multiplica cada píxel y los
de su alrededor por valores que se corresponden con una matriz, y luego se suman todos de forma
saturada, dicho valor representaría la derivada en para ese píxel. La matriz usada es dada por
la cátedra, pertenece al operador de derivación de Laplace.

-----------------------------------------------------------------------------------------------
                                         Hoja 0xB
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

  +--------------------------------------+    +--------------------------------------+
  |     ############################     |    |     +--------------------------+     |
  |     ############################     |    |     |                          |     |
  |                #######               |    |     +----------+     +---------+     |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |    ####        #######               |    |    +--+        |     |               |
  |    ####        #######               |    |    |  |        |     |               |
  |    ####        #######               |    |    +--+        |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               |
  |                #######               |    |                |     |               | 
  |                #######               |    |                |     |               | 
  |                #######               |    |                |     |               | 
  |                #######               |    |     +----------+     +---------+     | 
  |     ############################     |    |     |                          |     | 
  |     ############################     |    |     +--------------------------+     | 
  +--------------------------------------+    +--------------------------------------+ 



                  .-.
Implementación en |   :
                  `-'

    Arrancamos desde la fila 1, columna 1, y vamos sumando los valores en un int, columna por 
columna respetando la matriz, es decir, para el pixel en la posición y:1, x:1, sumamos los 
píxeles que corresponderían a la columna de la izquierda, multiplicandolos por los valores 
correspondientes según la matriz (0.5, 1, 0.5), luego para la columna central (1, -6, 1) y
finalmente para la columna de la derecha (0.5, 1, 0.5), luego de sumar todo esto en un int, 
lo saturamos, y ese sería el valor de la posición 1, 1. 


-----------------------------------------------------------------------------------------------
                                         Hoja 8
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------


                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Se copia la fila anterior a la que contiene el pixel que se quiere procesar, se hacen 
2 copias, shifteando una un byte a la derecha con psrldq, y otra dos bytes a la derecha, 
con la misma instrucción. Luego se desempaquetan las partes bajas de todos estos registros, se 
multiplican los correspondientes por el valor de la matriz (para dividir por 2 utilizamos 
psraw shifteando a la derecha 1 bit).
    Se suman todos estos valores de forma empaquetada, y se procesa la fila central, utilizando
el mismo mecanismo visto anteriormente de shifteo. Para multiplicar por -6, se resta 6 veces el
registro, así evitamos convertir a punto flotante.
    La tercer y última fila se procesa de igual manera que la primera. Luego se suma todo y se
empaqueta a bytes, ese resultado se copia a la imagen destino. 


-----------------------------------------------------------------------------------------------
                                         Hoja 0xC
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
                         
                         Proceso de Shifteo de Columnas

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00| xmm0
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |00|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01| xmm1
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |00|00|15|14|13|12|11|10|09|08|07|06|05|04|03|02| xmm2
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                  Desempaquetado (Se completa con 0's ya que son unsigned)

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  07 |  06 |  05 |  04 |  03 |  02 |  01 | 00  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm0
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  08 |  07 |  06 |  05 |  04 |  03 |  02 |  01 |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm1
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  09 |  08 |  07 |  06 |  05 |  04 |  03 |  02 | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm2
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+



-----------------------------------------------------------------------------------------------
                                         Hoja 9
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

           Cada registro es multiplicado por el elemento correspondiente de la matriz
            y luego se suman todos, se carga la próxima fila y esto se repite hasta 
              procesar todas las filas. Finalmente, el resultado de la suma
                queda en un solo registro que se empaqueta y se manda a guardar.

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  p7 |  p6 |  p5 |  p4 |  p3 |  p2 |  p1 |  p0 | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm0
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             | packuswb
                                             V
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     | 0| 0| 0| 0| 0| 0| 0| 0|p7|p6|p5|p4|p3|p2|p1|p0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm0
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+



                                      .dP"Y8  dP""b8    db    88     888888     oP"Yb. Yb  dP 
                                      `Ybo." dP   `"   dPYb   88     88__       "' dP'  YbdP  
                                      o.`Y8b Yb       dP__Yb  88  .o 88""         dP'   dPYb  
                                      8bodP'  YboodP dP""""Yb 88ood8 888888     .d8888 dP  Yb 


    De chicos todos soñamos con ser detectives y encontrar al ladrón que se robó las joyas tras
hacer un minuscioso peritaje sobre las filmaciones del edificio de enfrente de la escena del
crimen. Una herramienta fundamental para ello es poder hacer zoom sobre ciertos sectores de una
imagen, eso es lo que hace scale2x, escala el sector superior izquierdo de una imagen al doble 
de alto y ancho. 

 +--------------------------------------+           +--------------------------------------+
 |                  |2.71828182845904523|           |                                      |
 |  ##############  |5360287471352662497|           |     ############################     |
 |        ##        |7572470936999595749|           |     ############################     |
 |        ##        |6696762772407663035|           |                #######               |
 |        ##        |3547594571382178525|           |                #######               |
 |        ##        |1664274274663919320|           |                #######               |
 |        ##        |0305992181741359662|           |                #######               |
 |        ##        |9043572900334295260|           |                #######               |
 |        ##        |5956307381323286279|           |                #######               |
 |        ##        |4349076323382988075|           |                #######               |
 |  ##############  |3195251019011573834|           |                #######               |
 |                  |1879307021540891499|           |                #######               |
 +------------------+-------------------+ -> Scale  |                #######               |
 |--.- ..- . / .. -. --. . -. .. --- ...|           |                #######               |
 |--- ... --..-- / ... . / -. --- ... / |           |                #######               |
 |--- -.-. ..- .-. .-. .. --- / .--. ---|           |                #######               |
 |-. . .-. / .- .-.. --. --- / . -. /   |           |                #######               |
 |-.-. --- -.. .. --. --- / -- --- .-.  |           |                #######               |
 |... . / .- -.-. .- .-.-.- .-.-.- / .- |           |                #######               |
 |.-.. --. ..- .. . -. / .-.. --- / .-..|           |                #######               |
 |. . .-. .- ..--.. / ..- -. / ... .-   |           |                #######               |
 |.-.. ..- -.. --- / .--. .- .-. .- / - |           |                #######               |
 |--- -.. --- ... / .-.. --- ... / --.- |           |     ############################     |
 |..- . / -- . / -.-. --- -. --- -.-.   |           |     ############################     |
 |. -.                                  |           |                                      |
 +------------------+-------------------+           +--------------------------------------+

 

                  .-.
Implementación en |   :
                  `-'

    Como todas las implementaciones en C hasta ahora, la implementación de este filtro resulta
bastante trivial. Recorremos fila por fila y columna por columna hasta la mitad de la imagen, 
y para cada píxel tenemos un arreglo de punteros que apuntan a los píxeles que van a quedar
en cada posición en la imagen final (a partir de cada píxel la imagen final tiene 4 píxeles más
basándose en los píxeles adyacentes al original). Se setean los punteros correctos basado en 
lo provisto por la cátedra y al final de dicha elección se copian a la imagen destino. 



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para poder escalar cada píxel, necesitamos de sus adyacentes, por lo cual, cargando 4
píxeles en un registro xmm, podremos escalar los dos del medio, resultando en 8 píxeles de la
imágen destino. Cargamos las fila correspondiente al píxel, así como también la fila superior
y la inferior. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ xmm0
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                               Vamos a escalar Pixel 1 y Pixel 2


                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |           |           |           |           | Fila superior
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |           |           |           |           | Fila Inferior
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Luego Shifteamos para comparar el pixel 0 con el 2 y el 1 con el 3.

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |0x00000000 |0x00000000 |  Pixel 3  |  Pixel 2  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Luego comparamos los píxeles correspondientes a 1 y 2 de la fila superior e inferior, y
finalmente shifteamos estos resultados para poder compararlos con los obtenidos recién, 
de esta forma, conseguimos tener el resultado de la condición impuesta en el enunciado 
(B == H || D == F), teniendo para cada píxel el resultado correspondiente.

    El resultado de esta máscada lo replicamos utilizando pshufd, de la siguiente forma

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |           |           |B'=H'oD'=F'|B=H o D=F  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                      pshufd_magic_mask
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |B'=H'oD'=F'|B'=H'oD'=F'|B=H o D=F  |B=H o D=F  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Luego comezamos a aplicar máscaras para reordenar los píxeles que tenemos de forma que nos 
quede conveniente para procesar. Tanto en la fila superior, como en la inferior, reordenamos
los píxeles de la siguiente forma, ya que sólo nos interesan los que están arriba y abajo de 
cada píxel central. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                        pshufd-magic-mask-1
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 2  |  Pixel 2  |  Pixel 1  |  Pixel 1  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    A los píxeles de la fila central los reordenamos de la siguiente forma

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                        pshufd-magic-mask-2
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 1  |  Pixel 2  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Pero, además, nos guardamos una copia de la fila central reordenada de la siguiente forma:

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                        pshufd-magic-mask-1
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 2  |  Pixel 2  |  Pixel 1  |  Pixel 1  | 
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Esto es porque si la condición original (B = H o D = F) da falso, necesitamos quedarnos con 
los píxeles en este orden.

    Ahora que ya tenemos los registros reordenados, comparamos el superior con el del medio, el
inferior con el del medio, y aplicamos ands y pands para quedarnos con los resultados que 
buscamos. Vamos a usar la nomenclatura dada por el enunciado para nombrar a cómo tenemos los 
píxeles, siendo BDEFH los correspondientes al píxel 1 y B'D'E'F'H' los correspondientes al 
píxel 2. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |    B'     |     B'    |     B     |     B     |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                          pcmpeqd
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |    F'     |     D'    |     F     |     D     |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    Con esto obtenemos la máscara para saber si en el resultado tiene que ir, la D o la E, 
usando pand y pandn, con paddusb obtenemos el valor que corresponda para cada píxel. Notar que
 hacer esto mismo para la fila inferior es análogo.





                                                                88""Yb 88     88   88 88""Yb 
                                                                88__dP 88     88   88 88__dP 
                                                                88""Yb 88  .o Y8   8P 88"Yb  
                                                                88oodP 88ood8 `YbodP' 88  Yb 



    Desenfocar es sin lugar a dudas uno de los principales y más usados filtros para aplicar sobre 
imágenes. ¿De qué otra forma podríamos evitar que ese amigo feo que tenemos sea tan llamativo 
en una fotografía? Es por ello que en este trabajo práctico debemos realizar este filtro. 
El que se exija realizar una implementación eficiente utilizando SIMD para poder aplicar el 
filtro reiteradas veces, es algo que, por algún motivo que desconocemos, les era de particular 
interés a los profesores. ¿Será que sus amig... Mejor centrémonos. El filtro consiste en 
mezclar los píxeles cercanos para dar un efecto de desenfoque. Precisando, un píxel dado se 
calcula obteniendo el promedio de los 13 píxeles que distan menos de tres en la norma 
Manhattan. El promedio se calcula canal a canal.


                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para aprovechar mejor las instrucciones SSE es importante observar con detalle el filtro 
que se necesita implementar. Como procesaremos 4 píxeles a vez, es bueno ver bien qué píxeles 
entran en juego y qué rol cumplen. Un gráfico nos ayudará a aclarar esta cuestión:

      +-+-+-+-+          +-+-+-+-+          +-+-+-+-+          +-+-+-+-+          +-+-+-+-+    
      | | | | |          |*| | | |          | |*| | |          | | |*| |          | | | |*|    
    +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+  
    | | | | | | |      |*|*|*| | | |      | |*|*|*| | |      | | |*|*|*| |      | | | |*|*|*|  
  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+
  | | |A|B|C|D| | |  |*|*|A|*|*| | | |  | |*|*|B|*|*| | |  | | |*|*|C|*|*| |  | | | |*|*|D|*|*|
  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+
    | | | | | | |      |*|*|*| | | |      | |*|*|*| | |      | | |*|*|*| |      | | | |*|*|*|  
    +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+      +-+-+-+-+-+-+  
      | | | | |          |*| | | |          | |*| | |          | | |*| |          | | | |*|    
      +-+-+-+-+          +-+-+-+-+          +-+-+-+-+          +-+-+-+-+          +-+-+-+-+    

    En la primera imagen vemos los píxeles que deseamos procesar y todos los píxeles que se 
involucran. En las siguientes imágenes vemos píxel a píxel de los que deseamos procesar, 
cuáles son los píxeles involucrados. Todos se promedian de la misma manera, por lo que 
podríamos decir que juegan el mismo rol.

    Para guardar estos píxles en memoria, decidimos acomodarlos de la sigueinte manera:
      +-+-+-+-+    
      | xmm0  |    
  +-+-+-+-+-+-+-+-+  
  | xmm1  | xmm2  |  
  +-+-+-+-+-+-+-+-+
  | xmm3  | xmm4  |
  +-+-+-+-+-+-+-+-+
  | xmm5  | xmm6  | 
  +-+-+-+-+-+-+-+-+ 
      | xmm7  |    
      +-+-+-+-+    

    Donde A y B se encuentran en una mitad de xmm3, C y D en la otra de xmm4, y además 
xmm1, xmm2, xmm5 y xmm6 cada uno posee un pixel que no nos sirve.

    Lo interesante del asunto es que las dos primeras filas juegan exactamente el mismo rol que 
las dos últimas. Ignorando el posible overflow, hay que ejecutar exactamente las mismas 
instrucciones para procesar lo correspondiente a xmm1, xmm5 o xmm1+xmm5 (donde el + representa 
la suma componente a componente). El tema del overflow se soluciona un unpack de byte a word.
Por otro lado, xmm2 se procesa de fora simétrica a xmm1 y xmm4 se procesa de forma simétrica 
a xmm3. Por lo que hay sólo tres tipos de procesados que son únicos. El resto son formas 
distintas de aplicar esto. Más aún, antes de procesar xmm1, nos encargamos de desempaquetarlo 
y le sumamos xmm5 desempaquetado, procesando ambos registros de una sola vez. Un hecho extra 
interesante es que también le sumamos xmm3, dejando sólo una parte de xmm3 sin procesar que, 
como veremos, resulta muy sencilla de procesar. De forma completamente simétrica procesamos 
xmm2 + xmm4 + xmm6.

    Después de tanta cháchara pasemos a explicar cómo hacemos esto. Para el procesamiento de 
píxeles, nosotros tendremos dos registros xmm14 y xmm15 donde iremos guardando las sumas de 
todos los píxeles que correspondan. En xmm14 estarán los valores correspondientes a A y B y 
en xmm15 los correspondientes a C y D. Una vez sumado todo lo correspondiente, se pasa a 
dividir por 13 cada componente, siendo lo que quede el resultado correspondiente a cada pixel.

                                        Centrémonos en xmm1:
                                             +-+-+-+-+    
                                             | | | | |    
                                         +-+-+-+-+-+-+-+  
                                         | |X|Y|Z| | | |  
                                         +-+-+-+-+-+-+-+-+
                                         | | |A|B|C|D| | |
                                         +-+-+-+-+-+-+-+-+
                                           | |E|F| | | |  
                                           +-+-+-+-+-+-+  
                                             | | | | |    
                                             +-+-+-+-+    

    Lo que nosotros sabemos es que X, Y y Z influyen en el resultado de A, Y, Z en el de B y Z 
sólo en el de C. Como todo tiene el mismo rol, sumar antes de sacarse el promedio, por influir 
nos referimos a que van a ser sumados en la parte correspondiente de los registros 
xmm14 y xmm15
    Para notar el procesamiento paralelo en esto, lo que nosotros hacemos es lo siguiente:
        * Sumamos X a A
        * Sumamos al mismo tiempo Y y Z a A y B respectivamente
        * Invertimos las posiciones de Y y Z
        * Sumamos Z e Y a A y B respectivamente
        * Limpiamos Y dejando sólo a Z donde se encontraba
        * Sumamos Z a C
    En este último texto por A, B y C nos referimos a las posiciones correctas de xmm14 y xmm15
 que contienen los resultados temporales que irán a parar a las posiciones de A, B y C.

    Sólo por esta funciones mostraremos el snippet del código de asm para dejar en claro cómo 
es el procesado. Las otras otras partes no diferirán demasiado y por lo tanto llegado el 
momento las obviaremos:

        movdqa xmm8, xmm1          
        punpckhbw xmm8, xmm13            ;xmm8 = Y      , Z
        movdqa xmm9, xmm3
        punpckhbw xmm9, xmm13
        paddusw xmm15, xmm9
        paddusw xmm8, xmm9               ;xmm8 = Y + A  , Z + B
        movdqa xmm9, xmm5
        punpckhbw xmm9, xmm13
        paddusw xmm8, xmm9               ;xmm8 = Y + A + E, Z + B + F
        paddusw xmm14, xmm8              ;xmm14+= Y = A = E, Z = B + F
        pshufd xmm8, xmm8, invertmask    ;xmm8 = Z + B + F, Y + A + E
        paddusw xmm14, xmm8              ;xmm14 += Z + B + F, Y + A + E
        pslldq xmm8, 8                   ;xmm8 = 0          , Z + B + F
        psrldq xmm8, 8                   ;xmm8 = Z + B + F, 0
        paddusw xmm15, xmm8              ;xmm15+= Z + B + F, 0

    Donde en el registro xmm8 se ponen las sumas de la parte alta xmm1, xmm3 y xmm5 
(Y + A + E en una componente y Z + B + F en la otra) invertmask es una máscara que cambia de 
lugar los quadwords de xmm8, las instrucciones pslldq y pslrdq se utilizand para limpiar la 
mitad del registro xmm8 y xmm13 contiene todos ceros. La instrucción paddusw xmm15, xmm9 que
 está colgadísima en este lugar nos simplifica la vida a la hora de procesar lo que nos fata 
de xmm1, que luego veremos cuándo sucede.

Oh, sí, como decía mi abuelo: nada más claro que assembly para entender cómo funciona un 
programa.

Las dos formas restantes de procesar son bastante más sencillas:
     +-+-+-+-+          +-+-+-+-+     
     |X|Y| | |          | | | | |     
   +-+-+-+-+-+-+      +-+-+-+-+-+-+   
   | | | | | | |      | | | | | | |   
 +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+ 
 | | |A|B| | | | |  |X|Y|A|B|Z|W| | | 
 +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+ 
   | | | | | | |      | | | | | | |   
   +-+-+-+-+-+-+      +-+-+-+-+-+-+   
     | | | | |          | | | | |     
     +-+-+-+-+          +-+-+-+-+     

    Si hasta acá el proceso pudo ser comprendido, entonces se puede ver que para procesar 
xmm0 y xmm7 basta sumarlos directamente sobre el resultado (sumándose X en A e Y en B, más los 
respectivos valores de xmm7) y para procesar xmm3 y xmm4, hay que sumar X y Z en A e Y y 
W en B. También falta la parte completamente simétrica de xmm2, xmm4 y xmm6, pero por tal 
simetría nos ahorraremos las explicaciones. Basta con observar que tanto para A como para B, 
cada uno de los píxeles que se necesitaban fueron sumados, salvo uno de B (pero sumamos dos 
de C que al momento del procesamiento simétrico se corresponderá con los faltantes en B).
De este modo, en xmm14 y xmm15 tenemos las sumas correspondientes a los píxeles A, B, C y D 
canal a canal. Lo restante es desempaquetar una vez más, convertir a floating points, dividir 
por trece, reempaquetar todo y pasarlo a dst.



                  .-.
Implementación en |   :
                  `-' 

La implementación es C es bastante straightfoward. No difiere mucho con las otras funciones,
se procesa píxel por píxel, recorriendo fila por fila y columna por columna, haciendo la 
cuentita para cada píxel. 


  ___   _   _   ___   _     _____ _____ _____ _____ 
 / _ \ | \ | | / _ \ | |   |_   _/  ___|_   _/  ___|
/ /_\ \|  \| |/ /_\ \| |     | | \ `--.  | | \ `--. 
|  _  || . ` ||  _  || |     | |  `--. \ | |  `--. \
| | | || |\  || | | || |_____| |_/\__/ /_| |_/\__/ /
\_| |_/\_| \_/\_| |_/\_____/\___/\____/ \___/\____/ 


Se comparó la eficiencia de las implementaciones en C y en ASM com SSE. El resultado general 
es que las implementaciones en ASM son más eficienes que las de C.

Para realizar esta comparación se corrieron todos los filtros con todas las imágenes con cada 
implementación 40 veces cada combinación.

Veremos de forma puntual los resultados con una imagen en particular, pero adjuntaremos, 
aunque de forma desagradable, los resultados con todas las corridas.

Tomaremos como ejemplo la imagen de lena de 1024

Los resultados fueron:

blit           asm    ciclos: 162258576    ciclos por llamada: 4056464.500
blit           c      ciclos: 365623200    ciclos por llamada: 9140580.000
blur           asm    ciclos: 1119204100   ciclos por llamada: 27980102.000
blur           c      ciclos: 11412049068  ciclos por llamada: 285301216.000
edge           asm    ciclos: 164348024    ciclos por llamada: 4108700.750
edge           c      ciclos: 3306667652   ciclos por llamada: 82666696.000
monocromatizar asm    ciclos: 221693312    ciclos por llamada: 5542333.000
monocromatizar c      ciclos: 2102472740   ciclos por llamada: 52561816.000
rotar          asm    ciclos: 152051860    ciclos por llamada: 3801296.500
rotar          c      ciclos: 1724751136   ciclos por llamada: 43118776.000
scale2x        asm    ciclos: 143656564    ciclos por llamada: 3591414.000
scale2x        c      ciclos: 5252119656   ciclos por llamada: 131302992.000
sepia          asm    ciclos: 307983036    ciclos por llamada: 7699576.000
sepia          c      ciclos: 2708022848   ciclos por llamada: 67700568.000
smalltiles     asm    ciclos: 127812784    ciclos por llamada: 3195319.500
smalltiles     c      ciclos: 2171503312   ciclos por llamada: 54287584.000

    Como se puede observar en este caso en particular, las implementaciones en asm para esta 
imagen fueron significativamente más eficientes. Salvo blit que por tener poca lógica y 
tener que competir contra memcpy muchas posibilidades de arrasar no tenía, todos los otros 
filtros han sido por lo menos casi 10 veces más rápidos. Destacando el casi de scale2x que 
fue 36 veces más rápido en asm que en C.

    Pero lo importante no es observar que nuestras implementaciones han tenido la destacada 
peculiaridad de ser más eficientes cuando las hicimos en ASM que cuando las hicimos en C. 
La moraleja que hay que destacar está más relacionada con los motivos que no sólo hicieron 
que esto sucediera de esta manera, sino que hasta sugerían previamente que un resultado 
semejante a este se puede realizar.
    El quid de la cuestión se haya en el uso de las funciones SSE. Este set de instrucciones 
le permitieron a las funciones en ASM operar con mucho mayor volumen de datos en la misma 
cantidad de operaciones. Las operaciones SSE no sólo permitieron calcular varios píxeles en 
cada iteración de los ciclos que conformaban los filtros, sino que incluso permitían operar 
sobre varios canales a la vez. Mientras que desde el código de C se tuvo que trabajar píxel 
a píxel y, en muchas ocasiones, canal a canal.


 _____ _   _  _____    _   _ _____  _   __   __     ___   _   _  _______   __
|_   _| | | ||  ___|   | | | |  __ \| |  \ \ / /    / _ \ | \ | ||  ___\ \ / /
  | | | |_| || |__     | | | | |  \/| |   \ V /    / /_\ \|  \| || |__  \ V / 
  | | |  _  ||  __|    | | | | | __ | |    \ /     |  _  || . ` ||  __| /   \ 
  | | | | | || |___    | |_| | |_\ \| |____| |     | | | || |\  || |___/ /^\ \
  \_/ \_| |_/\____/     \___/ \____/\_____/\_/     \_| |_/\_| \_/\____/\/   \/


