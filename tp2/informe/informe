Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
 _____      _                 _                _                 
|_   _|    | |               | |              (_)              _ 
  | | _ __ | |_ _ __ ___   __| |_   _  ___ ___ _  ___  _ __   (_)
  | || '_ \| __| '__/ _ \ / _` | | | |/ __/ __| |/ _ \| '_ \     
 _| || | | | |_| | | (_) | (_| | |_| | (_| (__| | (_) | | | |  _ 
 \___/_| |_|\__|_|  \___/ \__,_|\__,_|\___\___|_|\___/|_| |_| (_)



       ....           urante la realización de este trabajo práctico hemos tenido que enfrentar
   .xH888888Hx.       la problemática de diseñar algoritmos que aprovechen el modelo SIMD 
 .H8888888888888:     provisto por la arquitectura Intel. Procesamos imágenes aplicando
 888*"""?""*88888X    distintos filtros implementados en el lenguaje ANSI-C y en el lenguaje 
'f     d8x.   ^%88k   Ensamblador (utilizando instrucciones SSE) y comparamos el rendimiento
'>    <88888X   '?8   obtenido. 
 `:..:`888888>    8> 
        `"*88     X     Los filtros a implementar eran rotar, monocromatizar, sepia, blit, 
   .xHHhx.."      !   scale2x, smalltiles, edge-detection y blur, que serán descriptos 
  X88888888hx. ..!    pertinentemente más adelante. 
 !   "*888888888"    
        ^"***"`         Para facilitar las pruebas y mediciones sobre los algoritmos, la 
cátedra nos ha provisto una cómoda interfaz de trabajo utilizando la librería de visión 
computacional "OpenCv" la cual nos entrega las imágenes en memoria, listas para ser procesadas,
 en un formato homogéneo (un byte por canal RGB).


______                               _ _           
|  _  \                             | | |        _ 
| | | |___  ___  __ _ _ __ _ __ ___ | | | ___   (_)
| | | / _ \/ __|/ _` | '__| '__/ _ \| | |/ _ \     
| |/ /  __/\__ \ (_| | |  | | | (_) | | | (_) |  _ 
|___/ \___||___/\__,_|_|  |_|  \___/|_|_|\___/  (_)

                                                        88""Yb  dP"Yb  888888    db    88""Yb 
                                                        88__dP dP   Yb   88     dPYb   88__dP 
                                                        88"Yb  Yb   dP   88    dP__Yb  88"Yb  
                                                        88  Yb  YbodP    88   dP""""Yb 88  Yb 

    El filtro rotar consiste en rotar los canales RGB de una imagen, de la siguiente manera:

                        +----------+----------+----------+
                        |  88""Yb  |  dP""b8  |  88""Yb  |
                        |  88__dP  | dP   `"  |  88__dP  |
                        |  88"Yb   | Yb  "88  |  88""Yb  |
                        |  88  Yb  |  YboodP  |  88oodP  |
                        +----------+----------+----------+
                             +---+      |          |
                                 v      |          |
                             +----------+   +------+
                             |   v          v
                             |   +-------------------+
                             |              v        |
                             v              v        v
                        +----------+----------+----------+
                        |  dP""b8  |  88""Yb  |  88""Yb  |
                        | dP   `"  |  88__dP  |  88__dP  |
                        | Yb  "88  |  88""Yb  |  88"Yb   |
                        |  YboodP  |  88oodP  |  88  Yb  |
                        +----------+----------+----------+
-----------------------------------------------------------------------------------------------
                                         Hoja 1

Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                  .-.
Implementación en |   :
                  `-' 

    La implementación de este filtro en el lenguaje ANSI C utilizando un modelo SISD resulta
trivial, iteramos la imagen en memoria recorriendo fila por fila, columna por columna, 
cambiando pixel por pixel el orden de sus componentes RGB.

                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para esta función, iteramos fila por fila, para cada una de ellas, procesamos de a 16 bytes
(4 píxels), cargándolos en registros XMM de forma alineada con la instrucción movdqa. Esto lo
hacemos solo para las direcciones alineadas a 16 bytes, claramente no todas las imágenes tienen
una cantidad de bytes por fila múltiplo de 16, así que para procesar el resto de los bytes
(a lo sumo 15), volvemos para "atras" hasta que nos queden 16 bytes por procesar, luego 
cargamos eso en registros XMM de forma desalineada con la instrucción movdqu.

    El procesamiento de 4 píxeles lo hacemos utilizando la instrucción pshufb, que se encarga
de reordenar los bytes de un registro xmm según una máscara dada.


                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|R3|G3|B3|A2|R2|G2|B2|A1|R1|G1|B1|A0|R0|G0|B0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                         pshufb_mask
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|G3|B3|R3|A2|G2|B2|R2|A1|G1|B1|R1|A0|G0|B0|R0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+



    Cada píxel es un grupo de 4 bytes, cuyas componentes son R, G, B y un byte más utilizado
para alineación. La parte inferior de cada cuadro muestra el índice del byte dentro del
registro xmm, mientras que la parte superior especifica qué componente es y de qué píxel forma
parte; así, se ve cómo el primer píxel intercambia los componentes RGB por GBR como se pide.


    Una vez aplicada la máscara, se mueve de forma alineada a la memoria destinada para la 
imagen resultante, de nuevo, los píxeles restantes se mueven de forma desalineada.








-----------------------------------------------------------------------------------------------
                                         Hoja 2
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                         .dP"Y8 8b    d8    db    88     88     888888 88 88     888888 .dP"Y8 
                         `Ybo." 88b  d88   dPYb   88     88       88   88 88     88__   `Ybo." 
                         o.`Y8b 88YbdP88  dP__Yb  88  .o 88  .o   88   88 88  .o 88""   o.`Y8b 
                         8bodP' 88 YY 88 dP""""Yb 88ood8 88ood8   88   88 88ood8 888888 8bodP' 

    Aplicar este filtro no es más que replicar la imagen original 4 veces sobre el destino de 
forma escalada. 

    +--------------------------------------+     +--------------------------------------+
    |                                      |     |                  |                   |
    |     ############################     |     |  ##############  |  ##############   |
    |     ############################     |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |                  |                   |
    |                #######               |     +------------------+-------------------+
    |                #######               |     |                  |                   |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |     ############################     |     |        ##        |        ##         |
    |     ############################     |     |  ##############  |  ##############   |
    |                                      |     |                  |                   |
    +--------------------------------------+     +------------------+-------------------+


                  .-.
Implementación en |   :
                  `-' 

    Si la imagen tiene un alto o ancho impar, se descarta el último píxel del lado impar para
poder procesarlo como una imagen con lados pares. Se procesa fila por medio, columna por medio
copiando sólo los píxeles en posiciones pares a las 4 posiciones diferentes en la imágen
destino. Se copia componente a componente, primero en el cuadrante superior izquierdo, luego
en el superior derecho, después inferior derecho, y finalmente inferior izquierdo. 












-----------------------------------------------------------------------------------------------
                                         Hoja 3
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Dado que sólo tenemos que copiar la mitad de los píxeles (de cada 4 píxeles copiamos el 
primero y el tercero), cargamos 16 bytes en un registro (xmm1), y aplicamos una máscara 
utilizando la instrucción pshufd, la cual reordena los dwords dentro un registro xmm según 
una máscara dada. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                 pshufd_mask (máscara 0x00001000)
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 0  |  Pixel 0  |  Pixel 2  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


    Copiamos la parte baja de este registro xmm resultante a las cuatro posiciones
correspondientes en el destino, en sentido horario, comenzando a partir del segundo cuadrante.
 Esta copia la hacemos usando la instrucción movq.

    Como es observable, si la imágen no tiene tamaño múltiplo de 16, los últimos cuatro píxeles
podrían quedar sin procesar, es por eso que cuando llegamos al final, utilizamos el mismo 
método del filtro anterior para procesarlos, volvemos para atrás lo suficiente para poder 
cargar 16 bytes de forma no alineada en un registro xmm.




                                                                       88""Yb 88     88 888888 
                                                                       88__dP 88     88   88   
                                                                       88""Yb 88  .o 88   88   
                                                                       88oodP 88ood8 88   88  


    El arte del blitting es el proceso de combinar dos mapas de bits en uno solo. Para este
trabajo nos vemos ante la problemática de pegar una imagen sobre otra, asumiendo que el píxel
color magenta representa la transparencia, y, por ende, que de ese pixel queda la imagen de 
fondo.








































