Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
 _____      _                 _                _                 
|_   _|    | |               | |              (_)              _ 
  | | _ __ | |_ _ __ ___   __| |_   _  ___ ___ _  ___  _ __   (_)
  | || '_ \| __| '__/ _ \ / _` | | | |/ __/ __| |/ _ \| '_ \     
 _| || | | | |_| | | (_) | (_| | |_| | (_| (__| | (_) | | | |  _ 
 \___/_| |_|\__|_|  \___/ \__,_|\__,_|\___\___|_|\___/|_| |_| (_)



       ....           urante la realización de este trabajo práctico hemos tenido que enfrentar
   .xH888888Hx.       la problemática de diseñar algoritmos que aprovechen el modelo SIMD 
 .H8888888888888:     provisto por la arquitectura Intel. Procesamos imágenes aplicando
 888*"""?""*88888X    distintos filtros implementados en el lenguaje ANSI-C y en el lenguaje 
'f     d8x.   ^%88k   Ensamblador (utilizando instrucciones SSE) y comparamos el rendimiento
'>    <88888X   '?8   obtenido. 
 `:..:`888888>    8> 
        `"*88     X     Los filtros a implementar eran rotar, monocromatizar, sepia, blit, 
   .xHHhx.."      !   scale2x, smalltiles, edge-detection y blur, que serán descriptos 
  X88888888hx. ..!    pertinentemente más adelante. 
 !   "*888888888"    
        ^"***"`         Para facilitar las pruebas y mediciones sobre los algoritmos, la 
cátedra nos ha provisto una cómoda interfaz de trabajo utilizando la librería de visión 
computacional "OpenCv" la cual nos entrega las imágenes en memoria, listas para ser procesadas,
 en un formato homogéneo (un byte por canal RGB).


______                               _ _           
|  _  \                             | | |        _ 
| | | |___  ___  __ _ _ __ _ __ ___ | | | ___   (_)
| | | / _ \/ __|/ _` | '__| '__/ _ \| | |/ _ \     
| |/ /  __/\__ \ (_| | |  | | | (_) | | | (_) |  _ 
|___/ \___||___/\__,_|_|  |_|  \___/|_|_|\___/  (_)

                                                        88""Yb  dP"Yb  888888    db    88""Yb 
                                                        88__dP dP   Yb   88     dPYb   88__dP 
                                                        88"Yb  Yb   dP   88    dP__Yb  88"Yb  
                                                        88  Yb  YbodP    88   dP""""Yb 88  Yb 

    El filtro rotar consiste en rotar los canales RGB de una imagen, de la siguiente manera:

                        +----------+----------+----------+
                        |  88""Yb  |  dP""b8  |  88""Yb  |
                        |  88__dP  | dP   `"  |  88__dP  |
                        |  88"Yb   | Yb  "88  |  88""Yb  |
                        |  88  Yb  |  YboodP  |  88oodP  |
                        +----------+----------+----------+
                             +---+      |          |
                                 v      |          |
                             +----------+   +------+
                             |   v          v
                             |   +-------------------+
                             |              v        |
                             v              v        v
                        +----------+----------+----------+
                        |  dP""b8  |  88""Yb  |  88""Yb  |
                        | dP   `"  |  88__dP  |  88__dP  |
                        | Yb  "88  |  88""Yb  |  88"Yb   |
                        |  YboodP  |  88oodP  |  88  Yb  |
                        +----------+----------+----------+
-----------------------------------------------------------------------------------------------
                                         Hoja 1

Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                  .-.
Implementación en |   :
                  `-' 

    La implementación de este filtro en el lenguaje ANSI C utilizando un modelo SISD resulta
trivial, iteramos la imagen en memoria recorriendo fila por fila, columna por columna, 
cambiando pixel por pixel el orden de sus componentes RGB.

                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para esta función, iteramos fila por fila, para cada una de ellas, procesamos de a 16 bytes
(4 píxels), cargándolos en registros XMM de forma alineada con la instrucción movdqa. Esto lo
hacemos solo para las direcciones alineadas a 16 bytes, claramente no todas las imágenes tienen
una cantidad de bytes por fila múltiplo de 16, así que para procesar el resto de los bytes
(a lo sumo 15), volvemos para "atras" hasta que nos queden 16 bytes por procesar, luego 
cargamos eso en registros XMM de forma desalineada con la instrucción movdqu.

    El procesamiento de 4 píxeles lo hacemos utilizando la instrucción pshufb, que se encarga
de reordenar los bytes de un registro xmm según una máscara dada.


                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|R3|G3|B3|A2|R2|G2|B2|A1|R1|G1|B1|A0|R0|G0|B0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                         pshufb_mask
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |A3|G3|B3|R3|A2|G2|B2|R2|A1|G1|B1|R1|A0|G0|B0|R0|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+



    Cada píxel es un grupo de 4 bytes, cuyas componentes son R, G, B y un byte más utilizado
para alineación. La parte inferior de cada cuadro muestra el índice del byte dentro del
registro xmm, mientras que la parte superior especifica qué componente es y de qué píxel forma
parte; así, se ve cómo el primer píxel intercambia los componentes RGB por GBR como se pide.


    Una vez aplicada la máscara, se mueve de forma alineada a la memoria destinada para la 
imagen resultante, de nuevo, los píxeles restantes se mueven de forma desalineada.








-----------------------------------------------------------------------------------------------
                                         Hoja 2
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

                         .dP"Y8 8b    d8    db    88     88     888888 88 88     888888 .dP"Y8 
                         `Ybo." 88b  d88   dPYb   88     88       88   88 88     88__   `Ybo." 
                         o.`Y8b 88YbdP88  dP__Yb  88  .o 88  .o   88   88 88  .o 88""   o.`Y8b 
                         8bodP' 88 YY 88 dP""""Yb 88ood8 88ood8   88   88 88ood8 888888 8bodP' 

    Aplicar este filtro no es más que replicar la imagen original 4 veces sobre el destino de 
forma escalada. 

    +--------------------------------------+     +--------------------------------------+
    |                                      |     |                  |                   |
    |     ############################     |     |  ##############  |  ##############   |
    |     ############################     |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |                  |                   |
    |                #######               |     +------------------+-------------------+
    |                #######               |     |                  |                   |
    |                #######               |     |  ##############  |  ##############   |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |                #######               |     |        ##        |        ##         |
    |     ############################     |     |        ##        |        ##         |
    |     ############################     |     |  ##############  |  ##############   |
    |                                      |     |                  |                   |
    +--------------------------------------+     +------------------+-------------------+


                  .-.
Implementación en |   :
                  `-' 

    Si la imagen tiene un alto o ancho impar, se descarta el último píxel del lado impar para
poder procesarlo como una imagen con longitudes pares. Se procesa fila por medio, columna por
medio copiando sólo los píxeles en posiciones pares a las 4 posiciones diferentes en la imágen
destino. Se copia componente a componente, primero en el cuadrante superior izquierdo, luego
en el superior derecho, después inferior derecho, y finalmente inferior izquierdo. 












-----------------------------------------------------------------------------------------------
                                         Hoja 3
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Dado que sólo tenemos que copiar la mitad de los píxeles (de cada 4 píxeles copiamos el 
primero y el tercero), cargamos 16 bytes en un registro (xmm1), y aplicamos una máscara 
utilizando la instrucción pshufd, la cual reordena los dwords dentro un registro xmm según 
una máscara dada. 

                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                                             |
                                             |
                                 pshufd_mask (máscara 0x00001000)
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |  Pixel 0  |  Pixel 0  |  Pixel 2  |  Pixel 0  |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


    Copiamos la parte baja de este registro xmm resultante a las cuatro posiciones
correspondientes en el destino, en sentido horario, comenzando a partir del segundo cuadrante.
 Esta copia la hacemos usando la instrucción movq.

    Como es observable, si la imágen no tiene tamaño múltiplo de 16, los últimos cuatro píxeles
podrían quedar sin procesar, es por eso que cuando llegamos al final, utilizamos el mismo 
método del filtro anterior para procesarlos, volvemos para atrás lo suficiente para poder 
cargar 16 bytes de forma no alineada en un registro xmm.




                                                                       88""Yb 88     88 888888 
                                                                       88__dP 88     88   88   
                                                                       88""Yb 88  .o 88   88   
                                                                       88oodP 88ood8 88   88  


    El arte del blitting es el proceso de combinar dos mapas de bits en uno solo. Para este
trabajo nos vemos ante la problemática de pegar una imagen sobre otra, asumiendo que el píxel
color magenta representa la transparencia, y, por ende, que de ese pixel queda la imagen de 
fondo. ¿Quién no ha querido sacarse una foto con nuestro compañero, el General Juan Domingo?
Gracias a los avances tecnológicos que nos brinda la manipulación digital de imágenes, con 
BLIT esto es posible. 






-----------------------------------------------------------------------------------------------
                                         Hoja 4
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------
    +--------------------------------------+                       +-------------------+
    |                      __    __        |        +--+           |      |^ ^|        |
    |                     /  \__/  \__     |        |  |           |      |___|        |
    |  _                 /___         \    |     +--+  +--+        |       \ /         |
    | / \ ____  ____         \__    __/    |     |        |        |       ###   #     |
    |/   /    \/    \           \__/       |     +--+  +--+        |   ###########     |
    |\              /                      |        |  |           |  #   #####        |
    | |  _          \                      |        +--+           |      #####        |
    | \_/ \_________/                      |                       |     #     #       |
    |           3.141592                   |                       |    ##     ##      |
    |          6535897932                  |                       |  ####     ####    |
    |         385626433832                 |                       +-------------------+
    |          7950288419                  |
    |           7169399                    |
    |             |  |                     |
    |             |  |                     |
    |             |  |                  <*>|
    |_____________|  |___________________|_|
    |                                      |
    |                                      |
    |                                      |
    +--------------------------------------+

                           +--------------------------+
                           |                          |
                           |                          |
                           +--------------------------+


                           +--------------------------+
                           |                          |
                           |                          |
                           +--------------------------+


                            +--------------------------------------+
                            |                      __    __        |
                            |                     /  \__/  \__     |
                            |  _                 /___         \    |
                            | / \ ____  ____         \__    __/    |
                            |/   /    \/    \           \__/       |
                            |\              /                      |
                            | |  _          \                      |
                            | \_/ \_________/                      |
                            |           3.141592                   |
                            |          6535897932                  |
                            |         385626433832    |^ ^|        |
                            |          7950288419     |___|        |
                            |           7169399        \ /         |
                            |             |  |         ###   #     |
                            |             |  |     ###########     |
                            |             |  |    #   #####     <*>|
                            |_____________|  |________#####______|_|
                            |                        #     #       |
                            |                       ##     ##      |
                            |                     ####     ####    |
                            +--------------------------------------+


-----------------------------------------------------------------------------------------------
                                         Hoja 5
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------


                  .-.
Implementación en |   :
                  `-'

    Ya que sabemos que el blit lo debemos posicionar abajo a la derecha de nuestra imagen
destino, utilizando la función MEMCPY extraída de la librería estándard de ANSI C para copiar
la imagen tal cual en el destino. Esto lo hacemos fila por fila, ya que no podemos pisar la
memoria que hay entre el final de una fila y la fila siguiente (width <= row_size), y tampoco
podemos asumir que src_row_size sea igual a dst_row_size.

    Una vez copiada toda la imagen, procedemos a copiar el blit, recorriendo fila por fila del
blit, columna por columna, copiando los píxeles que no son magenta en la imagen destino.

    Es probable, dependiendo del compilador con la que se haya compilado la LibC de la pc donde
corra el programa, que MEMCPY use instrucciones SSE para realizar la copia. Esto se tendrá en 
cuenta en el análisis de rendimiento.



                  .-. .-. .  . 
Implementación en |-| `-. |\/| :
                  ` ' `-' '  ` 

    Para la implementación en ASSEMBLER, aprovechamos lo mismo que en la implementación de C,
copiando primero todas las filas que no entren en el blit " a lo bruto", con la instrucción
movdqa para hacerlo de forma alineada y luego retrocediendo y usando la instrucción movdq para
los, a lo sumo, 15 bytes restantes.

    Una vez llegada a una fila en la que se debería insertar el blit, se van copiando las
columnas hasta llegar a la última que sea múltiplo de 16 sin que empiece formando parte del
blit, se copia, se vuelve al inicio del blit, y se aplica el blit de forma no alineada para 
source (en breve veremos en qué consiste aplicar el blit). Luego se vuelve a ir hacia donde 
nos habíamos quedado, y empezamos a aplicar el blit de forma alineada para source, pero 
desalineada para el blit. Esto es así ya que nada nos asegura que podamos realizar ambas copias
de forma alineada. Finalmente, llegamos a los últimos píxeles que no entran en un registro xmm
sin pisar la memoria fuera de la imagen, por esto, volvemos para atrás la cantidad necesaria
de bytes y volvemos a procesarlos de forma alineada, como hicimos en todos los ejercicios hasta
ahora.

    Aplicar el blit, hace referencia al proceso de mezclar los dos mapas de bit, el de origen
(source), y el del blit, sobre la imagen destino (dest). Esto lo hacemos usando comparaciones
y operaciones lógicas empaquetadas. Se tienen 4 píxeles contiguos cargados en un registro XMM, 
luego se utiliza la operación pcmpeqd que compara, de forma empaquetada, los double-words que
se encuentran en un registro contra los double-words de otro registro, en el cual tenemos 4
double-words con el píxel color magenta. Esto nos genera una máscara con unos en los
double-words que corresponden a píxeles magenta, y 0 donde no hay magenta. Al momento de 
combinarlas, si en el blit tenemos un pixel magenta, queremos que en dest prevalezca el pixel 
de source, si en el blit el píxel no es magenta, en dest debería prevalecer el píxel del blit.
Es por eso, que luego de hacer pcmpeqd, hacemos un pand entre los píxeles de source y los 
resultantes del pcmpeqd, de esta forma, nos quedarían sólo los píxeles de source que 
corresponden a píxeles magenta del blit; luego hacemos pandn entre el resultado de pcmpeqd y
el blit, quedandonos así con los píxeles del blit que no son magenta. Finalmente, combinamos 
ambos registros mediante la instrucción por, es claro ver que o nos queda un pixel de source
o nos queda un pixel de blit, y que no se nos mezclan. En esto consiste "aplicar el blit". 



-----------------------------------------------------------------------------------------------
                                         Hoja 6
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------

Source:
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |  Pixel 3  |  Pixel 2  |  Pixel 1  |  Pixel 0  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

Blit:
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |  MAGENTA  |Pixel 2blit|Pixel 1blit|  MAGENTA  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|             |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+             |
                                                            pcmpeqd----+
Mascara Magenta                                                |       |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+             |       |
 |  MAGENTA  |  MAGENTA  |  MAGENTA  |  MAGENTA  |             |       |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+       |
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|                     |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                     |
                                                                       |
                                                                       |
                                             +-------------------------+
                                             |
                                             |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |0xFFFFFFFF |0x00000000 |0x00000000 |0xFFFFFFFF |
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                     |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  
                                             |
                                             |             
                         +-------------------+----------------------+
                         |                                          |
                      pand Source                              pandn Blit
                         |                                          |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
 |  Pixel 3  |0x00000000 |0x00000000 |  Pixel 0  |                  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
 |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|                  |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+                  |
                         |                                          |
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                  |0x00000000 |Pixel 2blit|Pixel 1blit|0x00000000 |
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                  |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                         |                  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                         |                                          |
                         |                                          |
                         |                    por                   |
                         +---------------------+--------------------+
                                               |
                                               |
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                       |  Pixel 3  |Pixel 2blit|Pixel 1blit|  Pixel 0  |
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                       |15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
                       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-----------------------------------------------------------------------------------------------
                                         Hoja 7
Marquez, Somodi, Vanotti                   |                      Organización Del Computador 2
-----------------------------------------------------------------------------------------------










